name: Ko Release

on: 
  workflow_dispatch:
    inputs:
      registry:
        type: choice
        description: Registry
        options: 
        - docker.io
        - ghcr.io
  push:
    tags:
      - "*" 

permissions: read-all

env:
  DOCKER_REGISTRY: docker.io
  GITHUB_REGISTRY: ghcr.io

jobs:
  build-release:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      PLATFORMS: "linux/amd64,linux/arm64,linux/386,linux/arm"
      TAGS: "tag1,tag2,tag3"
      # Note: "." works to in this simple case
      PROJECT: "laurentsimon/helloworld"
      GIHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
      DOCKER_TOKEN: "${{ secrets.DOCKER_TOKEN }}"
      USERNAME: "laurentsimon"
    outputs:
      docker-image: ${{ steps.docker.outputs.docker-image }}
      github-image: ${{ steps.docker.outputs.github-image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        
       # Note: downlaoading and pinning the download seems better
       # than adding this dependency. Need to look how the install works
       # remko/dsadmin/blob/7a6939179bc56b1be28cada040f2b4a148e3e14a/.github/workflows/publish-release.yml
      - name: Setup Ko
        uses: imjasonh/setup-ko@v0.4
    
      - name: docker
        id: docker
        if: ${{ github.event.inputs.registry == env.DOCKER_REGISTRY}}
        run: |
          set -euo pipefail
          
          ko login docker.io -u laurentsimon -p "$DOCKER_TOKEN"
          
          # Note: this will be done in Go.
          # Note 2: we will use a dr-run to generate the command.
          export KO_DOCKER_REPO="docker.io/laurentsimon"
          DOCKER_IMAGE=$(ko publish -B --platform "$PLATFORMS" --tags "$TAGS" "$PROJECT")
          echo "::set-output name=docker-image::$DOCKER_IMAGE"
      
      - name: github
        if: ${{ github.event.inputs.registry == env.GITHUB_REGISTRY}}
        run: |
          set -euo pipefail
          
          ko login ghcr.io -u laurentsimon -p "$GIHUB_TOKEN"
          GITHUB_IMAGE=$(ko publish -B --platform "$PLATFORMS" --tags "$TAGS" "$PROJECT")
          echo "::set-output name=github-image::$GITHUB_IMAGE"
  
  provenance-generation:
    runs-on: ubuntu-latest
    needs: build-release
    outputs:
      filename: ${{ steps.provenance.outputs.filename }}
      sha256: ${{ steps.provenance.outputs.sha256 }}
    env:
      UNTRUSTED_DOCKER_IMAGE: "${{ needs.build-release.outputs.docker-image }}"
      UNTRUSTED_GITHUB_IMAGE: "${{ needs.build-release.outputs.github-image }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        
      - name: Provenance generation
        id: provenance
        run: |
          set -euo pipefail
          
          echo "github-image: $UNTRUSTED_GITHUB_IMAGE"
          # Note: let's do that without using docker binary if possible. Can use cosign APIs?
          echo "TODO: pull the image and verify its digest"
          
          if [ -n "$UNTRUSTED_DOCKER_IMAGE" ]; then
                echo "docker-image: $UNTRUSTED_DOCKER_IMAGE"
                CONTAINER_IMAGE="$UNTRUSTED_DOCKER_IMAGE"
          elif [ -n "$UNTRUSTED_GITHUB_IMAGE" ]; then
                echo "github-image: $UNTRUSTED_GITHUB_IMAGE"
                CONTAINER_IMAGE="$UNTRUSTED_GITHUB_IMAGE"
          fi
          
          if [ -n "$CONTAINER_IMAGE" ]; then
            echo "no container image found"
            exit 2
          fi
          
          echo "::set-output name=filename::$CONTAINER_IMAGE.intoto.jsonl"
          echo "::set-output name=sha256::prov-hash"
  
  provenance-upload:
    runs-on: ubuntu-latest
    needs: provenance-generation
    env:
      UNTRUSTED_PROVENANCE_FILENAME: "${{ needs.provenance-generation.outputs.filename }}"
      PROVENANCE_SHA256: "${{ needs.provenance-generation.outputs.sha256 }}"
    steps:
      - name: Docker upload
        run: |
          set -euo pipefail
          echo "uploading: $UNTRUSTED_PROVENANCE_FILENAME"
          #TODO: verify hash
          echo "sha256: $PROVENANCE_SHA256"
         
