name: Ko Release

on: 
  workflow_dispatch:
    inputs:
      registry:
        type: choice
        description: Registry
        options: 
        - docker.io
        - ghcr.io
  push:
    tags:
      - "*" 

permissions: read-all

env:
  DOCKER_REGISTRY: docker.io
  GITHUB_REGISTRY: ghcr.io

jobs:
  build-release:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      PLATFORMS: "linux/amd64,linux/arm64,linux/386,linux/arm"
      TAGS: tag1,tag2,tag3
      # Note: "." works to in this simple case
      GIHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      USERNAME: laurentsimon
      PROJECT: laurentsimon/helloworld
    outputs:
      docker-image: ${{ steps.docker.outputs.docker-image }}
      github-image: ${{ steps.github.outputs.github-image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        
       # Note: downlaoading and pinning the download seems better
       # than adding this dependency. Need to look how the install works
       # remko/dsadmin/blob/7a6939179bc56b1be28cada040f2b4a148e3e14a/.github/workflows/publish-release.yml
      - name: Setup Ko
        uses: imjasonh/setup-ko@v0.4
    
      - name: docker
        id: docker
        if: ${{ github.event.inputs.registry == env.DOCKER_REGISTRY}}
        run: |
          set -euo pipefail
          
          echo ko login "${{ env.DOCKER_REGISTRY }}" -u "$USERNAME" -p "$DOCKER_TOKEN"
          ko login "${{ env.DOCKER_REGISTRY }}" -u "$USERNAME" -p "$DOCKER_TOKEN"
          
          # Note: this will be done in Go.
          # Note 2: we will use a dr-run to generate the command.
          export KO_DOCKER_REPO="${{ env.DOCKER_REGISTRY }}/$USERNAME"
          DOCKER_IMAGE=$(ko publish -B --platform "$PLATFORMS" --tags "$TAGS" "$PROJECT")
          
          echo "::set-output name=docker-image::$DOCKER_IMAGE"
      
      - name: github
        id: github
        if: ${{ github.event.inputs.registry == env.GITHUB_REGISTRY}}
        run: |
          set -euo pipefail
          
          echo ko login "${{ env.GITHUB_REGISTRY }}" -u "$USERNAME" -p "$GIHUB_TOKEN"
          ko login "${{ env.GITHUB_REGISTRY }}" -u "$USERNAME" -p "$GIHUB_TOKEN"
          
          echo ko publish -B --platform "$PLATFORMS" --tags "$TAGS" "$PROJECT"
          
          GITHUB_IMAGE=$(ko publish -B --platform "$PLATFORMS" --tags "$TAGS" "$PROJECT")
          
          echo "github-image is $GITHUB_IMAGE"
          
          echo "::set-output name=github-image::$GITHUB_IMAGE"
  
  provenance-generation:
    runs-on: ubuntu-latest
    needs: build-release
    outputs:
      filename: ${{ steps.provenance.outputs.filename }}
      sha256: ${{ steps.provenance.outputs.sha256 }}
    env:
      UNTRUSTED_DOCKER_IMAGE: "${{ needs.build-release.outputs.docker-image }}"
      UNTRUSTED_GITHUB_IMAGE: "${{ needs.build-release.outputs.github-image }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        
      - name: Provenance generation
        id: provenance
        run: |
          set -euo pipefail
          
          # Note: let's do that without using docker binary if possible. Can use cosign APIs?
          echo "TODO: pull the image and verify its digest"
          
          CONTAINER_IMAGE=""
  
          if [[ ! -z "$UNTRUSTED_DOCKER_IMAGE" ]]; then
            echo "docker-image: $UNTRUSTED_DOCKER_IMAGE"
            CONTAINER_IMAGE="$UNTRUSTED_DOCKER_IMAGE"
          elif [[ ! -z "$UNTRUSTED_GITHUB_IMAGE" ]]; then
            echo "github-image: $UNTRUSTED_GITHUB_IMAGE"
            CONTAINER_IMAGE="$UNTRUSTED_GITHUB_IMAGE"
          else
            echo "no container image found"
            exit 2
          fi
          
          
          
          echo "image is: $CONTAINER_IMAGE"
          
          
          #TODO: generate PROJECT dynamically using the URL
          # testing. Use a local file containing provenance.
          CONTAINER_SHA256=$(echo $CONTAINER_IMAGE | cut -d "@" -f2 | cut -d ":" -f2)
          CONTAINER_PROVENANCE="sha256-$CONTAINER_SHA256.intoto.jsonl"
          echo "provenance is: $CONTAINER_PROVENANCE"
          
          echo "TODO: upload artifact"
          
          echo "provenance for container with digest $CONTAINER_SHA256" > "$CONTAINER_PROVENANCE"
          
          echo "::set-output name=filename::$CONTAINER_PROVENANCE"
          echo "::set-output name=sha256::prov-hash"
  
  provenance-upload:
    runs-on: ubuntu-latest
    needs: provenance-generation
    env:
      UNTRUSTED_PROVENANCE_FILENAME: "${{ needs.provenance-generation.outputs.filename }}"
      PROVENANCE_SHA256: "${{ needs.provenance-generation.outputs.sha256 }}"
      GIHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
      USERNAME: laurentsimon
      PROJECT: laurentsimon/helloworld
    steps:
      # We may be able to have a generic provenance uploader, but for now let's seperate to keep things simple.
      - name: Github upload
        if: ${{ github.event.inputs.registry == env.GITHUB_REGISTRY}}
        run: |
          set -euo pipefail
          echo "uploading to ${{ github.event.inputs.registry }}: $UNTRUSTED_PROVENANCE_FILENAME"
          
          # verify logs
          #echo "$GIHUB_TOKEN" | docker login "${{ env.GITHUB_REGISTRY }}" -u "$USERNAME" --password-stdin
          ko login "${{ env.GITHUB_REGISTRY }}" -u "$USERNAME" -p "$GIHUB_TOKEN"
          
          # TODO: upload our provenance blob
          #TODO: verify hash
          echo "sha256: $PROVENANCE_SHA256"
          
      - name: Docker upload
        if: ${{ github.event.inputs.registry == env.DOCKER_REGISTRY}}
        run: |
          set -euo pipefail
          echo "uploading to ${{ github.event.inputs.registry }}: $UNTRUSTED_PROVENANCE_FILENAME"
          
          # verify logs
          ko login "${{ env.DOCKER_REGISTRY }}" -u "$USERNAME" -p "$DOCKER_TOKEN"
          
          #TODO: download artifact
          echo "provenance for container is BLABLA" > "$UNTRUSTED_PROVENANCE_FILENAME"
          
          echo cosign upload blob -ct "application/vnd.dsse.envelope.v1+json" \
            -f "$UNTRUSTED_PROVENANCE_FILENAME" \
            "$PROJECT:$UNTRUSTED_PROVENANCE_FILENAME"
            
          cosign upload blob -ct "application/vnd.dsse.envelope.v1+json" \
            -f "$UNTRUSTED_PROVENANCE_FILENAME" \
            "$PROJECT:$UNTRUSTED_PROVENANCE_FILENAME"

          # TODO: upload our provenance blob
          #TODO: verify hash
          echo "sha256: $PROVENANCE_SHA256"
         
